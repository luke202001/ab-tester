"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const archiver = require("archiver");
const qs_1 = require("qs");
const tar_fs_1 = require("tar-fs");
const zlib_1 = require("zlib");
const IODataSource_1 = require("./IODataSource");
const routes = {
    Acknowledge: (app, service) => `${routes.App(app)}/acknowledge/${service}`,
    App: (app) => `${routes.Apps}/${app}`,
    AppBundle: (app, path) => `${routes.App(app)}/bundle/${path}`,
    Apps: '/apps',
    Dependencies: '/dependencies',
    File: (app, path) => `${routes.Files(app)}/${path}`,
    Files: (app) => `${routes.App(app)}/files`,
    Link: (app) => `/v2/links/${app}`,
    Links: '/links',
    ResolveDependencies: 'dependencies/_resolve',
    Settings: (app) => `${routes.App(app)}/settings`,
    Unlink: (app) => `${routes.Links}/${app}`,
};
const contextQuery = (context) => context ? context.join('/') : context;
const getVendorAndName = ({ id }) => id.split('@')[0];
const notFound = (e) => {
    if (e.response && e.response.status === 404) {
        return {};
    }
    throw e;
};
const zipObj = (keys, values) => {
    let idx = 0;
    const len = Math.min(keys.length, values.length);
    const out = {};
    while (idx < len) {
        out[keys[idx]] = values[idx];
        idx += 1;
    }
    return out;
};
const paramsSerializer = (params) => {
    return qs_1.stringify(params, { arrayFormat: 'repeat' });
};
class Apps extends IODataSource_1.IODataSource {
    constructor() {
        super(...arguments);
        this.httpClientFactory = IODataSource_1.forWorkspace;
        this.service = 'apps';
        this.installApp = (descriptor) => {
            return this.http.post(routes.Apps, { id: descriptor });
        };
        this.uninstallApp = (app) => {
            return this.http.delete(routes.App(app));
        };
        this.acknowledgeApp = (app, service) => {
            return this.http.put(routes.Acknowledge(app, service));
        };
        this.link = (app, files, { zlib } = {}) => __awaiter(this, void 0, void 0, function* () {
            if (!(files[0] && files[0].path)) {
                throw new Error('Argument files must be an array of {path, content}, where content can be a String, a Buffer or a ReadableStream.');
            }
            const emptyChanges = files.filter(file => !file.content);
            if (emptyChanges.length > 0) {
                throw new Error(`Missing content for paths: ${emptyChanges.map(e => e.path).join('; ')}`);
            }
            const indexOfManifest = files.findIndex(({ path }) => path === 'manifest.json');
            if (indexOfManifest === -1) {
                throw new Error('No manifest.json file found in files.');
            }
            const zip = archiver('zip', { zlib });
            // Throw stream errors so they reject the promise chain.
            zip.on('error', (e) => {
                throw e;
            });
            const request = this.http.put(routes.Link(app), zip, {
                headers: { 'Content-Type': 'application/zip' },
            });
            files.forEach(({ content, path }) => zip.append(content, { name: path }));
            const finalize = zip.finalize();
            try {
                const [response] = yield Promise.all([request, finalize]);
                response.bundleSize = zip.pointer();
                return response;
            }
            catch (e) {
                e.bundleSize = zip.pointer();
                throw e;
            }
        });
        this.patch = (app, changes, { zlib } = {}) => __awaiter(this, void 0, void 0, function* () {
            if (!(changes[0] && changes[0].path)) {
                throw new Error('Argument changes must be an array of {path, content}, where content can be a String, a Buffer or a ReadableStream.');
            }
            const files = changes.filter(change => !!change.content);
            const deletedFiles = changes
                .filter(change => !change.content)
                .map(change => change.path)
                .join(':');
            const zip = archiver('zip', { zlib });
            // Throw stream errors so they reject the promise chain.
            zip.on('error', (e) => {
                throw e;
            });
            const request = this.http.patch(routes.Link(app), zip, {
                headers: { 'Content-Type': 'application/zip' },
                params: { deletedFiles },
            });
            files.forEach(({ content, path }) => zip.append(content, { name: path }));
            const finalize = zip.finalize();
            const [response] = yield Promise.all([request, finalize]);
            return response;
        });
        this.unlink = (app) => {
            return this.http.delete(routes.Unlink(app));
        };
        this.unlinkAll = () => {
            return this.http.delete(routes.Links);
        };
        this.saveAppSettings = (app, settings) => {
            const headers = { 'Content-Type': 'application/json' };
            return this.http.put(routes.Settings(app), settings, { headers });
        };
        this.listApps = ({ oldVersion, context, since, service } = {}) => {
            const params = {
                context: contextQuery(context),
                oldVersion,
                service,
                since,
            };
            return this.http.get(routes.Apps, { params });
        };
        this.listAppFiles = (app, { prefix, context, nextMarker } = {}) => {
            const params = {
                context: contextQuery(context),
                marker: nextMarker,
                prefix,
            };
            return this.http.get(routes.Files(app), { params });
        };
        this.listLinks = () => {
            return this.http.get(routes.Links);
        };
        this.getAppFile = (app, path, context = []) => {
            const params = { context: contextQuery(context) };
            return this.http.getBuffer(routes.File(app, path), { params });
        };
        this.getAppFileStream = (app, path, context = []) => {
            const params = { context: contextQuery(context) };
            return this.http.getStream(routes.File(app, path), { params });
        };
        this.getApp = (app, context = []) => {
            const params = { context: contextQuery(context) };
            return this.http.get(routes.App(app), { params });
        };
        this.getAppSettings = (app) => {
            return this.http.get(routes.Settings(app));
        };
        this.getAllAppsSettings = (listAppsOptions = {}) => {
            return this.listApps(listAppsOptions).then(({ data: installedApps }) => {
                const names = installedApps.map(getVendorAndName);
                const settingsPromises = names.map(vendorAndName => this.getAppSettings(vendorAndName).catch(notFound));
                return Promise.all(settingsPromises).then((settings) => {
                    return zipObj(names, settings);
                });
            });
        };
        this.getAppBundle = (app, bundlePath, generatePackageJson) => {
            const params = generatePackageJson && { _packageJSONEngine: 'npm', _packageJSONFilter: 'vtex.render-builder@x' };
            return this.http.getStream(routes.AppBundle(app, bundlePath), {
                headers: {
                    Accept: 'application/x-gzip',
                    'Accept-Encoding': 'gzip',
                },
                params,
            });
        };
        this.unpackAppBundle = (app, bundlePath, unpackPath, generatePackageJson) => {
            return this.getAppBundle(app, bundlePath, generatePackageJson)
                .then(stream => stream
                .pipe(zlib_1.createGunzip())
                .pipe(tar_fs_1.extract(unpackPath)));
        };
        this.getDependencies = (filter = '') => {
            const params = { filter };
            return this.http.get(routes.Dependencies, { params });
        };
        this.updateDependencies = () => {
            return this.http.put(routes.Dependencies);
        };
        this.updateDependency = (name, version, registry) => {
            return this.http.patch(routes.Apps, [{ name, version, registry }]);
        };
        this.resolveDependencies = (apps, registries, filter = '') => {
            const params = { apps, registries, filter };
            return this.http.get(routes.ResolveDependencies, { params, paramsSerializer });
        };
    }
}
exports.Apps = Apps;
