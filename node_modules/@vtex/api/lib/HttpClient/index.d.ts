/// <reference types="node" />
import { DataSource } from 'apollo-datasource';
import { IncomingMessage } from 'http';
import { Context } from 'koa';
import { ParsedUrlQuery } from 'querystring';
import { CacheLayer } from '../caches/CacheLayer';
import { MetricsAccumulator } from '../metrics/metricsAccumulator';
import { MetricsLogger } from '../metrics/metricsLogger';
import { RequestConfig } from './context';
import { Cached } from './middlewares/cache';
import { Recorder } from './middlewares/recorder';
export declare class HttpClient {
    static forWorkspace(service: string, context: IOContext, opts: InstanceOptions): HttpClient;
    static forRoot(service: string, context: IOContext, opts: InstanceOptions): HttpClient;
    static forLegacy(endpoint: string, opts: LegacyInstanceOptions): HttpClient;
    private runMiddlewares;
    constructor(opts: ClientOptions);
    get: <T = any>(url: string, config?: RequestConfig) => Promise<T>;
    getRaw: <T = any>(url: string, config?: RequestConfig) => Promise<IOResponse<T>>;
    getBuffer: (url: string, config?: RequestConfig) => Promise<{
        data: Buffer;
        headers: any;
    }>;
    getStream: (url: string, config?: RequestConfig) => Promise<IncomingMessage>;
    put: <T = void>(url: string, data?: any, config?: RequestConfig) => Promise<T>;
    post: <T = void>(url: string, data?: any, config?: RequestConfig) => Promise<T>;
    postRaw: <T = void>(url: string, data?: any, config?: RequestConfig) => Promise<IOResponse<T>>;
    patch: <T = void>(url: string, data?: any, config?: RequestConfig) => Promise<T>;
    delete: (url: string, config?: RequestConfig | undefined) => Promise<IOResponse<void>>;
    private request;
}
export declare const withoutRecorder: (ioContext: IOContext) => IOContext;
export declare type CacheStorage = CacheLayer<string, Cached>;
export declare type Recorder = Recorder;
export interface DataSources {
    [name: string]: DataSource<ServiceContext>;
}
export interface ServiceContext extends Context {
    vtex: IOContext;
    dataSources?: DataSources;
    metricsLogger?: MetricsLogger;
}
export interface IOContext {
    account: string;
    authToken: string;
    production: boolean;
    recorder?: Recorder;
    region: string;
    route: {
        declarer?: string;
        id: string;
        params: ParsedUrlQuery;
    };
    userAgent: string;
    workspace: string;
    segmentToken?: string;
    sessionToken?: string;
}
export interface InstanceOptions {
    timeout?: number;
    cacheStorage?: CacheLayer<string, Cached>;
    endpoint?: string;
}
export interface LegacyInstanceOptions {
    authToken: string;
    userAgent: string;
    timeout?: number;
    accept?: string;
    cacheStorage?: CacheLayer<string, Cached>;
}
export interface IOResponse<T> {
    data: T;
    headers: any;
    status: number;
}
declare enum AuthType {
    bearer = "bearer",
    token = "token"
}
interface ClientOptions {
    authType?: AuthType;
    authToken?: string;
    userAgent: string;
    baseURL?: string;
    timeout?: number;
    recorder?: Recorder;
    metrics?: MetricsAccumulator;
    cacheStorage?: CacheLayer<string, Cached>;
    segmentToken?: string;
    sessionToken?: string;
}
export {};
