"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const compose = require("koa-compose");
const cache_1 = require("./middlewares/cache");
const metrics_1 = require("./middlewares/metrics");
const notFound_1 = require("./middlewares/notFound");
const recorder_1 = require("./middlewares/recorder");
const request_1 = require("./middlewares/request");
const DEFAULT_TIMEOUT_MS = 10000;
const noTransforms = [(data) => data];
const rootURL = (service, { region }, { endpoint }) => {
    if (endpoint) {
        return 'http://' + endpoint;
    }
    if (region) {
        return `http://${service}.${region}.vtex.io`;
    }
    throw new Error('Missing required: should specify either {region} or {endpoint}');
};
const workspaceURL = (service, context, opts) => {
    const { account, workspace } = context;
    if (!account || !workspace) {
        throw new Error('Missing required arguments: {account, workspace}');
    }
    return rootURL(service, context, opts) + `/${account}/${workspace}`;
};
class HttpClient {
    constructor(opts) {
        this.get = (url, config = {}) => {
            const cacheableConfig = Object.assign({}, config, { url, cacheable: true });
            return this.request(cacheableConfig).then(response => response.data);
        };
        this.getRaw = (url, config = {}) => {
            const cacheableConfig = Object.assign({}, config, { url, cacheable: true });
            return this.request(cacheableConfig);
        };
        this.getBuffer = (url, config = {}) => {
            const bufferConfig = Object.assign({}, config, { url, responseType: 'arraybuffer', transformResponse: noTransforms });
            return this.request(bufferConfig);
        };
        this.getStream = (url, config = {}) => {
            const streamConfig = Object.assign({}, config, { url, responseType: 'stream', transformResponse: noTransforms });
            return this.request(streamConfig).then(response => response.data);
        };
        this.put = (url, data, config = {}) => {
            const putConfig = Object.assign({}, config, { url, data, method: 'put' });
            return this.request(putConfig).then(response => response.data);
        };
        this.post = (url, data, config = {}) => {
            const postConfig = Object.assign({}, config, { url, data, method: 'post' });
            return this.request(postConfig).then(response => response.data);
        };
        this.postRaw = (url, data, config = {}) => {
            const postConfig = Object.assign({}, config, { url, data, method: 'post' });
            return this.request(postConfig);
        };
        this.patch = (url, data, config = {}) => {
            const patchConfig = Object.assign({}, config, { url, data, method: 'patch' });
            return this.request(patchConfig).then(response => response.data);
        };
        this.delete = (url, config) => {
            const deleteConfig = Object.assign({}, config, { url, method: 'delete' });
            return this.request(deleteConfig);
        };
        this.request = (config) => __awaiter(this, void 0, void 0, function* () {
            const context = { config };
            yield this.runMiddlewares(context);
            return context.response;
        });
        const { baseURL, authToken, authType, cacheStorage, metrics, recorder, userAgent, timeout = DEFAULT_TIMEOUT_MS, segmentToken } = opts;
        const headers = {
            'Accept-Encoding': 'gzip',
            'User-Agent': userAgent,
        };
        if (authType && authToken) {
            headers['Authorization'] = `${authType} ${authToken}`; // tslint:disable-line
        }
        this.runMiddlewares = compose([
            request_1.defaultsMiddleware(baseURL, headers, timeout),
            ...recorder ? [recorder_1.recorderMiddleware(recorder)] : [],
            notFound_1.acceptNotFoundMiddleware,
            ...cacheStorage ? [cache_1.cacheMiddleware({ cacheStorage, segmentToken: segmentToken || '' })] : [],
            notFound_1.notFoundFallbackMiddleware,
            ...metrics ? [metrics_1.metricsMiddleware(metrics)] : [],
            request_1.requestMiddleware,
        ]);
    }
    static forWorkspace(service, context, opts) {
        const { authToken, userAgent, recorder, segmentToken, sessionToken } = context;
        const { timeout, cacheStorage } = opts;
        const baseURL = workspaceURL(service, context, opts);
        return new HttpClient({ baseURL, authType: AuthType.bearer, authToken, userAgent, timeout, recorder, cacheStorage, segmentToken, sessionToken });
    }
    static forRoot(service, context, opts) {
        const { authToken, userAgent, recorder, segmentToken, sessionToken } = context;
        const { timeout, cacheStorage } = opts;
        const baseURL = rootURL(service, context, opts);
        return new HttpClient({ baseURL, authType: AuthType.bearer, authToken, userAgent, timeout, recorder, cacheStorage, segmentToken, sessionToken });
    }
    static forLegacy(endpoint, opts) {
        const { authToken, userAgent, timeout, cacheStorage } = opts;
        return new HttpClient({ baseURL: endpoint, authType: AuthType.token, authToken, userAgent, timeout, cacheStorage });
    }
}
exports.HttpClient = HttpClient;
exports.withoutRecorder = (ioContext) => {
    return Object.assign({}, ioContext, { recorder: undefined });
};
var AuthType;
(function (AuthType) {
    AuthType["bearer"] = "bearer";
    AuthType["token"] = "token";
})(AuthType || (AuthType = {}));
