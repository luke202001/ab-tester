"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const stringify = require("json-stringify-safe");
const PQueue = require("p-queue");
const ramda_1 = require("ramda");
const HttpClient_1 = require("./HttpClient");
const IODataSource_1 = require("./IODataSource");
const DEFAULT_SUBJECT = '-';
const PICKED_AXIOS_PROPS = ['baseURL', 'cacheable', 'data', 'finished', 'headers', 'method', 'timeout', 'status', 'path', 'url'];
const queue = new PQueue({ concurrency: 1 });
const routes = {
    Log: (level) => `/logs/${level}`,
};
const errorReplacer = (key, value) => {
    if (key.startsWith('_')) {
        return undefined;
    }
    if (value && typeof value === 'string' && value.length > 1024) {
        return value.substr(0, 256) + '[...TRUNCATED]';
    }
    return value;
};
const forWorkspaceWithoutRecorder = ({ service, context, options }) => (service && context)
    ? HttpClient_1.HttpClient.forWorkspace(service, HttpClient_1.withoutRecorder(context), options || {})
    : undefined;
class Logger extends IODataSource_1.IODataSource {
    constructor() {
        super(...arguments);
        this.service = 'colossus';
        this.httpClientFactory = forWorkspaceWithoutRecorder;
        this.debug = (message, subject = DEFAULT_SUBJECT) => this.sendLog(subject, message, 'debug');
        this.info = (message, subject = DEFAULT_SUBJECT) => this.sendLog(subject, message, 'info');
        this.warn = (message, subject = DEFAULT_SUBJECT) => this.sendLog(subject, message, 'warn');
        this.error = (error, details, subject = DEFAULT_SUBJECT) => {
            if (!error) {
                error = new Error('Colossus.error was called with null or undefined error');
                error.code = 'ERR_NIL_ERR';
                console.error(error);
            }
            const { code: errorCode, message, stack, config, request, response } = error, rest = __rest(error, ["code", "message", "stack", "config", "request", "response"]);
            const code = errorCode || response && `http-${response.status}`;
            const pickedDetails = Object.assign({}, config ? { config: ramda_1.pick(PICKED_AXIOS_PROPS, config) } : undefined, request ? { request: ramda_1.pick(PICKED_AXIOS_PROPS, request) } : undefined, response ? { response: ramda_1.pick(PICKED_AXIOS_PROPS, response) } : undefined, JSON.parse(stringify(rest, errorReplacer)), details);
            const hasDetails = Object.keys(pickedDetails).length > 0;
            return this.sendLog(subject, { code, message, stack, details: hasDetails ? pickedDetails : undefined }, 'error');
        };
        this.sendLog = (subject, message, level) => {
            return queue.add(() => this.http.put(routes.Log(level), message, { params: { subject } }));
        };
    }
}
exports.Logger = Logger;
