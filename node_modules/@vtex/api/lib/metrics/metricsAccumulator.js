"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ramda_1 = require("ramda");
const stats_lite_1 = require("stats-lite");
const Time_1 = require("../utils/Time");
let lastCpu = process.cpuUsage();
function cpuUsage() {
    const diff = process.cpuUsage(lastCpu);
    lastCpu = {
        system: lastCpu.system + diff.system,
        user: lastCpu.user + diff.user,
    };
    return diff;
}
const createMetricToAggregateReducer = (production) => (value, key, obj) => {
    const aggregate = {
        name: key,
        count: value.length,
        max: Math.max(...value),
        mean: stats_lite_1.mean(value),
        median: stats_lite_1.median(value),
        percentile95: stats_lite_1.percentile(value, 0.95),
        percentile99: stats_lite_1.percentile(value, 0.99),
        production,
    };
    delete obj[key];
    return aggregate;
};
class MetricsAccumulator {
    constructor() {
        this.metricToAggregate = createMetricToAggregateReducer(true);
        this.devMetricToAggregate = createMetricToAggregateReducer(false);
        this.batchHrTimeMetricFromEnd = (name, end, production) => {
            this.batchMetric(name, Time_1.hrToMillis(end), production);
        };
        this.batchHrTimeMetric = (name, start, production) => {
            this.batchMetric(name, Time_1.hrToMillis(process.hrtime(start)), production);
        };
        this.batchMetric = (name, timeMillis, production) => {
            if (production) {
                if (!this.metricsMillis[name]) {
                    this.metricsMillis[name] = [];
                }
                this.metricsMillis[name].push(timeMillis);
            }
            else {
                if (!this.devMetricsMillis[name]) {
                    this.devMetricsMillis[name] = [];
                }
                this.devMetricsMillis[name].push(timeMillis);
            }
        };
        this.addOnFlushMetric = (metricFn) => {
            this.onFlushMetrics.push(metricFn);
        };
        this.trackCache = (name, cacheInstance) => {
            this.cacheMap[name] = cacheInstance;
        };
        this.statusTrack = () => {
            return this.flushMetrics();
        };
        this.cacheToMetric = (value, key) => (Object.assign({ name: `${key}-cache` }, value.getStats()));
        this.flushMetrics = () => {
            const aggregateMetrics = ramda_1.values(ramda_1.mapObjIndexed(this.metricToAggregate, this.metricsMillis));
            const aggregateDevMetrics = ramda_1.values(ramda_1.mapObjIndexed(this.devMetricToAggregate, this.devMetricsMillis));
            const systemMetrics = [
                Object.assign({ name: 'cpu' }, cpuUsage()),
                Object.assign({ name: 'memory' }, process.memoryUsage()),
            ];
            const onFlushMetrics = ramda_1.flatten(ramda_1.map(getMetric => getMetric(), this.onFlushMetrics));
            const cacheMetrics = ramda_1.values(ramda_1.mapObjIndexed(this.cacheToMetric, this.cacheMap));
            return [...systemMetrics, ...aggregateMetrics, ...aggregateDevMetrics, ...onFlushMetrics, ...cacheMetrics];
        };
        this.metricsMillis = {};
        this.devMetricsMillis = {};
        this.onFlushMetrics = [];
        this.cacheMap = {};
    }
}
exports.MetricsAccumulator = MetricsAccumulator;
