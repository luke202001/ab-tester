"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mime = require("mime-types");
const path_1 = require("path");
const zlib_1 = require("zlib");
const IODataSource_1 = require("./IODataSource");
const appId = process.env.VTEX_APP_ID;
const [runningAppName] = appId ? appId.split('@') : [''];
const routes = {
    Bucket: (bucket) => `/buckets/${runningAppName}/${bucket}`,
    File: (bucket, path) => `${routes.Bucket(bucket)}/files/${path}`,
    Files: (bucket) => `${routes.Bucket(bucket)}/files`,
};
const isVBaseOptions = (opts) => {
    return typeof opts !== 'string' && !(opts instanceof String);
};
class VBase extends IODataSource_1.IODataSource {
    constructor(context, options = {}) {
        super(context, options);
        this.httpClientFactory = IODataSource_1.forWorkspace;
        this.service = 'vbase';
        this.getBucket = (bucket) => {
            return this.http.get(routes.Bucket(bucket));
        };
        this.resetBucket = (bucket) => {
            return this.http.delete(routes.Files(bucket));
        };
        this.listFiles = (bucket, opts) => {
            let params = {};
            if (isVBaseOptions(opts)) {
                params = opts;
            }
            else if (opts) {
                params = { prefix: opts };
            }
            return this.http.get(routes.Files(bucket), { params });
        };
        this.getFile = (bucket, path) => {
            return this.http.getBuffer(routes.File(bucket, path));
        };
        this.getJSON = (bucket, path, nullIfNotFound) => {
            return this.http.get(routes.File(bucket, path), { nullIfNotFound });
        };
        this.getFileStream = (bucket, path) => {
            return this.http.getStream(routes.File(bucket, path));
        };
        this.saveFile = (bucket, path, stream, gzip = true, ttl) => {
            return this.saveContent(bucket, path, stream, { gzip, ttl });
        };
        this.saveJSON = (bucket, path, data) => {
            const headers = { 'Content-Type': 'application/json' };
            return this.http.put(routes.File(bucket, path), data, { headers });
        };
        this.saveZippedContent = (bucket, path, stream) => {
            return this.saveContent(bucket, path, stream, { unzip: true });
        };
        this.deleteFile = (bucket, path) => {
            return this.http.delete(routes.File(bucket, path));
        };
        this.saveContent = (bucket, path, stream, opts = {}) => {
            if (!stream.pipe || !stream.on) {
                throw new Error(`Argument stream must be a readable stream`);
            }
            const params = opts.unzip ? { unzip: opts.unzip } : {};
            const headers = {};
            let finalStream = stream;
            headers['Content-Type'] = mime.contentType(path_1.basename(path)) || 'application/octet-stream';
            if (opts.gzip) {
                headers['Content-Encoding'] = 'gzip';
                finalStream = stream.pipe(zlib_1.createGzip());
            }
            if (opts.ttl && Number.isInteger(opts.ttl)) {
                headers['X-VTEX-TTL'] = opts.ttl;
            }
            return this.http.put(routes.File(bucket, path), finalStream, { headers, params });
        };
        if (runningAppName === '') {
            throw new Error(`Invalid path to access Vbase. Variable VTEX_APP_ID is not available.`);
        }
    }
}
exports.VBase = VBase;
