"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ramda_1 = require("ramda");
class MultilayeredCache {
    constructor(caches) {
        this.caches = caches;
        this.hits = 0;
        this.total = 0;
        this.get = (key, fetcher) => __awaiter(this, void 0, void 0, function* () {
            let value;
            let maxAge;
            let successIndex = yield this.findIndex((cache) => __awaiter(this, void 0, void 0, function* () {
                const [getValue, hasKey] = yield Promise.all([cache.get(key), cache.has(key)]);
                value = getValue;
                return hasKey;
            }), this.caches);
            if (successIndex === -1) {
                if (fetcher) {
                    const fetched = yield fetcher();
                    value = fetched.value;
                    maxAge = fetched.maxAge;
                }
                else {
                    return undefined;
                }
                successIndex = Infinity;
            }
            const failedCaches = ramda_1.slice(0, successIndex, this.caches);
            const [firstPromise] = ramda_1.map(cache => cache.set(key, value, maxAge), failedCaches);
            yield firstPromise;
            return value;
        });
        this.set = (key, value, maxAge) => __awaiter(this, void 0, void 0, function* () {
            const isSet = yield Promise.all(ramda_1.map(cache => cache.set(key, value, maxAge), this.caches));
            return ramda_1.any(item => item, isSet);
        });
        this.has = (key) => __awaiter(this, void 0, void 0, function* () {
            const hasList = yield Promise.all(ramda_1.map(cache => cache.has(key), this.caches));
            return ramda_1.any(item => item, hasList);
        });
        this.getStats = (name = 'multilayred-cache') => {
            const multilayerStats = {
                hitRate: this.total > 0 ? this.hits / this.total : undefined,
                hits: this.hits,
                name,
                total: this.total,
            };
            this.resetCounters();
            return multilayerStats;
        };
        this.findIndex = (func, array) => __awaiter(this, void 0, void 0, function* () {
            this.total += 1;
            for (let index = 0; index < array.length; index++) {
                const hasKey = yield func(array[index]);
                if (hasKey) {
                    this.hits += 1;
                    return index;
                }
            }
            return -1;
        });
    }
    resetCounters() {
        this.hits = 0;
        this.total = 0;
    }
}
exports.MultilayeredCache = MultilayeredCache;
